<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Unlimited Lingo - A word game</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        width: 100vw;
        background: #121213;
        font-family: 'Clear Sans', 'Helvetica Neue', Arial, sans-serif;
        color: #d7dadc;
        overflow: auto;
      }
      button {
        cursor: pointer;
        outline: none;
        border: unset;
      }
      .slider {
        width: 32px;
        min-width: 32px;
        height: 20px;
        position: relative;
        border-radius: 50px;
        background: #565758;
        cursor: pointer;
      }
      .slider.on {
        background: #538d4e;
      }
      .slider::after {
        content: "";
        height: 16px;
        width: 16px;
        position: absolute;
        border-radius: 50px;
        background: white;
        top: 2px;
        transition: left 0.1s ease;
      }
      .slider.on::after {
        left: 14px;
      }
      .slider:not(.on)::after {
        left: 2px;
      }
      .header {
        display: flex;
        justify-content: space-between;
        align-items: end;
        height: 42px;
        padding-bottom: 16px;
        border-bottom: solid 1px #3a3a3c;
        min-width: 330px;
        max-width: 500px;
        width: 65vw;
        margin: 4px auto 16px auto;
        position: relative;
      }
      .header-actions button {
        background: transparent;
        color: #565758;
      }
      .title {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, calc(-50% - 2px));
        display: flex;
        flex-direction: column;
        align-items: center;
        text-transform: uppercase;
        font-weight: bold;
        letter-spacing: 0.2rem;
      }
      .title span:first-child {
        font-size: 36px;
        line-height: 40px;
      }
      .title span:last-child {
        font-size: 10px;
        letter-spacing: 11px;
        line-height: 12px;
      }
      @media (max-width: 360px) {
        .title span:first-child {
          font-size: 24px;
        }
        .title span:last-child {
          line-height: unset;
        }
      }
      .words {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      .word {
        display: flex;
        margin-top: 5px;
      }
      .letter {
        display: flex;
        justify-content: center;
        align-items: center;
        border: solid 2px #3a3a3c;
        width: 58px;
        height: 58px;
        font-size: 2rem;
        font-weight: bold;
        transform-origin: center;
        user-select: none;
      }
      .letter:not(:last-child) {
        margin-right: 5px;
      }
      .letter.correct {
        background: #538d4e;
        border-color: #538d4e;
      }
      .letter.semi {
        background: #b59f3b;
        border-color: #b59f3b;
      }
      .letter.incorrect {
        background: #3a3a3c;
        border-color: #3a3a3c;
      }
      .word:not(.attempted) .letter:not(:empty) {
        border-color: #565758;
      }
      .game-over .keyboard {
        opacity: 0;
        pointer-events: none;
      }
      .keyboard {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        transition: opacity 0.2s ease-in-out;
      }
      .keyboard-row {
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .keyboard-button {
        font-family: inherit;
        text-transform: uppercase;
        font-weight: bold;
        height: 44px;
        min-width: 44px;
        margin: 2px;
        color: #d7dadc;
        background: #717374;
        border-radius: 4px;
        transition: background 0.1s ease-in;
      }
      @media (max-width: 490px) {
        .keyboard-button {
          height: 52px;
          min-width: 31px;
        }
      }
      .keyboard-button.correct {
        background: #538d4e !important;
      }
      .keyboard-button.semi {
        background: #b59f3b;
      }
      .keyboard-button.incorrect {
        background: #3a3a3c;
      }
      .keyboard-button.larger {
        padding: 0 18px;
      }
      @media (max-width: 360px) {
        .keyboard-button.larger {
          padding: 0 6px;
        }
      }
      .end-actions {
        display: grid;
        grid-template-columns: auto auto;
        grid-template-rows: auto auto;
        grid-auto-flow: column;
        grid-column-gap: 32px;
        grid-row-gap: 2px;
        position: absolute;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        opacity: 0;
        pointer-events: none;
        text-align: center;
      }
      .game-over .end-actions {
        opacity: 1;
        pointer-events: unset;
        transition: opacity 0.2s ease-in;
      }
      .end-actions > span:first-of-type {
        font-size: 28px;
        font-weight: bold;
      }
      .end-actions > span:last-of-type {
        font-size: 12px;
      }
      button#playagain {
        background: #44dd55;
        border-radius: 6px;
        padding: 12px 24px;
        text-transform: uppercase;
        font-weight: bolder;
        color: white;
        white-space: pre-wrap;
        grid-row: span 2;
      }
      .toast {
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        background: #d7dadc;
        color: black;
        padding: 16px;
        font-weight: bolder;
        border-radius: 4px;
        pointer-events: none;
        z-index: 1000;
        position: fixed;
        top: 15vh;
        left: 50vw;
        animation: toast-birth 0.2s forwards;
        transform-origin: center;
      }
      @keyframes toast-birth {
        0% { transform: translateX(-50%); }
        80% { transform: translateX(-50%) scale(1.1); }
        100% { transform: translateX(-50%) scale(1); }
      }
      .backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #000;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
        pointer-events: none;
        z-index: 2000;
      }
      .backdrop.show {
        pointer-events: unset;
        opacity: 0.75;
      }
      .modal {
        position: fixed;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0;
        background: #121213;
        border: solid 1px #444;
        transition: opacity 0.2s ease-in-out;
        pointer-events: none;
        z-index: 2500;
        padding: 20px 64px 44px 64px;
      }
      @media (max-width: 360px) {
        .modal {
          padding: 20px 16px 44px 16px;
        }
      }
      .modal.show {
        pointer-events: unset;
        opacity: 1;
      }
      .modal-close, .howtoplay-close, .settings-close {
        position: absolute;
        top: 12px;
        right: 6px;
        background: transparent;
        color: #565758;
      }
      .modal-title {
        font-weight: bold;
        font-size: 14px;
        margin: 24px 0 12px 0;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      .modal-content {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      .statistics {
        display: grid;
        grid-template-rows: repeat(2, auto);
        grid-template-columns: auto;
        grid-auto-flow: column;
        grid-column-gap: 24px;
        align-items: center;
        text-align: center;
        letter-spacing: 0.05rem;
        white-space: pre-wrap;
      }
      .statistics > span:nth-child(2n + 1) {
        font-size: 36px;
        font-weight: 400;
      }
      .statistics > span:nth-child(2n) {
        font-size: 12px;
      }
      .distribution {
        display: grid;
        grid-template-columns: auto 1fr;
        grid-gap: 4px 8px;
        width: 100%;
        margin-top: 32px;
        margin-bottom: 32px;
        padding-top: 32px;
        position: relative;
      }
      .distribution::after {
        content: "Guess Distribution";
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        text-transform: uppercase;
        white-space: nowrap;
        font-weight: bold;
      }
      .distribution >:nth-child(2n + 1) {
        font-size: 12px;
        align-self: center;
      }
      .distribution >:nth-child(2n) {
        display: flex;
        justify-content: end;
        align-items: center;
        padding: 2px 0;
      }
      .distribution >:nth-child(2n) span {
        margin: 0 6px;
        font-size: 14px;
      }
      .share-button {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #3f7ad2;
        padding: 12px 40px;
        white-space: pre;
        text-transform: uppercase;
        font-weight: bold;
        color: white;
        font-size: 20px;
        font-family: inherit;
        border-radius: 4px;
      }
      .overlay {
        position: fixed;
        z-index: 3000;
        top: 0;
        bottom: 0;
        left: 15%;
        right: 15%;
        background: #121213;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease-in;
        padding: 0 20px;
      }
      @media (max-width: 740px) {
        .overlay {
          left: 0;
          right: 0;
          padding: 0 20px;
        }
      }
      .overlay.show {
        opacity: 1;
        pointer-events: unset;
      }
      .howtoplay {
        display: flex;
        flex-direction: column;
        padding-top: 12px;
        font-size: 14px;
        position: relative;
      }
      .howtoplay:not(.show) {
        display: none;
      }
      .letters-example > div {
        margin-right: 2px;
        border: solid 1px #565758;
        width: 38px;
        height: 38px;
        color: #d7dadc;
        font-size: 2rem;
        line-height: 2rem;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 12px;
        margin-top: 32px;
      }
      .line-sep {
        width: 100%;
        height: 1px;
        background: #3a3a3c;
      }
      .settings {
        display: flex;
        flex-direction: column;
        padding-top: 12px;
        font-size: 14px;
        position: relative;
        user-select: none;
      }
      .settings:not(.show) {
        display: none;
      }
      .settings > div:not(.line-sep) {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
        padding: 0 12px;
      }
    </style>
  </head>
  <body class="" onload="onInit()">
    <div class="header">
      <div class="header-actions">
        <button id="howtoplay"></button>
      </div>
      <div class="title">
        <span>LÄ±ngo</span>
        <span>BBFC</span>
      </div>
      <div class="header-actions">
        <button id="stats"></button>
        <button id="settings"></button>
      </div>
    </div>
    <div class="words"></div>
    <span id="candidates-left" style="margin-top: 16px;"></span>
    <div style="position: relative; margin-top: 16px;">
      <div class="keyboard"></div>
      <div class="end-actions">
        <span id="word-answer"></span>
        <span>Answer</span>
        <button id="playagain" tabindex="-1" onclick="onClickPlayAgain()">Play<br>Again</button>
      </div>
    </div>
    <div class="modal">
      <button class="modal-close"></button>
      <div class="modal-title"></div>
      <div class="modal-content"></div>
    </div>
    <div class="overlay"><div class="howtoplay">
      <button class="howtoplay-close"></button>
      <b style="align-self: center; font-size: 17px;">HOW TO PLAY</b>
      <br>
      <span>Guess the <b>WORDLE</b> in 6 attempts.</span>
      <br>
      <span>Each guess must be a valid 5 letter word. Hit the Enter button to submit an attempt.</span>
      <br>
      <span>After each guess, the color of the tiles will change to show how close your guess was to the word.</span>
      <br>
      <div class="line-sep"></div>
      <br>
      <b>Examples</b>
      <div style="display: flex;" class="letters-example">
        <div style="background: #538d4e; border-color: #538d4e;">W</div>
        <div>E</div>
        <div>A</div>
        <div>R</div>
        <div>Y</div>
      </div>
      <span>The letter W is in the word and in the correct spot.</span>
      <div style="display: flex;" class="letters-example">
        <div>P</div>
        <div style="background: #b59f3b; border-color: #b59f3b;">I</div>
        <div>L</div>
        <div>L</div>
        <div>S</div>
      </div>
      <span>The letter I is in the word but in the wrong spot.</span>
      <div style="display: flex;" class="letters-example">
        <div>V</div>
        <div>A</div>
        <div>G</div>
        <div style="background: #3a3a3c; border-color: #3a3a3c;">U</div>
        <div>E</div>
      </div>
      <span>The letter U is not in the word in any spot.</span>
        </div>
          <div class="settings">
            <button class="settings-close"></button>
            <br>
           <b style="align-self: center; font-size: 17px;">SETTINGS</b>
        </div>
    </div>
    <div class="backdrop"></div>
  </body>
  <script>
    const dictionaries = {}
    const state = {
      config: {
        attempts: 6,
        wordLength: 5,
        hardMode: false,
        ultraHardMode: false,
        displayCandidates: false,
        autoFirstWord: false,
        quickAnimations: false
      },
      lettersTried: {},
      wordsTried: [],
      wordToGuess: '',
      gamesPlayed: 0,
      gamesWon: 0,
      victoryStreak: 0,
      victoryStreakRecord: 0,
      guessDistribution: {}
    }

    function cloneState () {
      return {
        lettersTried: { ...state.lettersTried },
        wordsTried: state.wordsTried.slice(),
        wordToGuess: state.wordToGuess
      }
    }

    function displayToast (message, duration = 1.5e3, zIndex = 500) {
      document.querySelectorAll('.toast').forEach(node => node.remove())
      if (!message) {
        return
      }
      let div = document.createElement('div')
      let span = document.createElement('span')
      div.classList.add('toast')
      div.append(span)
      div.style.zIndex = zIndex
      if (state.wordsTried.length === 1) {
        div.style.top = '32vh'
      }
      span.innerText = message
      document.body.append(div)
      setTimeout(() => {
        div.animate({ opacity: 0, easing: 'ease-out' }, { duration: 300, fill: 'forwards' })
          .addEventListener('finish', () => div.remove())
      }, duration)
    }

    function getCurrentWordDiv (offset = 0) {
      return Array.from(document.querySelector('.words').children)[state.wordsTried.length + offset]
    }

    function getCurrentTypedWord () {
      let div = getCurrentWordDiv()
      return (div && div.textContent) || ''
    }

    function getLetterDiv (filled = false) {
      let letterIndexFrom = state.wordsTried.length * state.config.wordLength
      let letters = Array.from(document.querySelectorAll('.letter'))
        .slice(letterIndexFrom, letterIndexFrom + state.config.wordLength)
      return filled
        ? letters.reverse().find(node => node.childElementCount !== 0)
        : letters.find(node => node.childElementCount === 0)
    }

    function isAnimatingHints () {
      const wordDiv = getCurrentWordDiv(-1)
      if (!wordDiv) {
        return false
      }
      const lettersDivs = Array.from(wordDiv.children)
      return lettersDivs.some(l => l.getAnimations().some(a => a.playState !== 'finished'))
    }

    function addHints (wordDiv, onEndAnimation, quick = state.config.quickAnimations) {
      return new Promise((resolve, reject) => {
        if (!wordDiv) {
          wordDiv = getCurrentWordDiv()
        }
        let lettersToGuess = Array.from(state.wordToGuess)
        let lettersGuessed = Array.from(wordDiv.textContent.toLowerCase())
        let lettersDivs = Array.from(wordDiv.children)
        let hints = lettersToGuess.slice()
        let animationDuration = 350
        let letterClasses = {}
        for (let index = 0; index < state.config.wordLength; index++) {
          let correctLetter = lettersToGuess[index]
          let guessedLetter = lettersGuessed[index]
          if (correctLetter === guessedLetter) {
            hints[index] = undefined
            letterClasses[index] = 'correct'
          }
        }
        for (let index = 0; index < state.config.wordLength; index++) {
          if (letterClasses[index] === 'correct') {
            continue
          }
          let correctLetter = lettersToGuess[index]
          let guessedLetter = lettersGuessed[index]
          let letterClass = 'incorrect'
          if (hints.includes(guessedLetter)) {
            let semiIndex = hints.indexOf(guessedLetter)
            hints[semiIndex] = undefined
            letterClass = 'semi'
          }
          letterClasses[index] = letterClass
        }
        for (let index = 0; index < state.config.wordLength; index++) {
          let letterDiv = lettersDivs[index]
          let guessedLetter = lettersGuessed[index]
          let keyboardKeyState = state.lettersTried[guessedLetter] || ''
          let keyboardKeyNextState = letterClasses[index]
          letterDiv
            .animate({ transform: [ 'rotateX(0)', 'rotateX(-90deg)' ] }, {
              duration: animationDuration * 0.5,
              delay: index * animationDuration - (quick ? 250 : 20) * index,
              fill: 'forwards'
            })
            .addEventListener('finish', (event) => {
              event.target.finish()
              let letterClass = letterClasses[index]
              if (letterClass) {
                letterDiv.classList.add(letterClass)
                let keyboardKeyState = state.lettersTried[guessedLetter] || ''
                if (!keyboardKeyState || keyboardKeyState === 'incorrect' ||
                    (keyboardKeyState === 'semi' && letterClass === 'correct') ||
                    (keyboardKeyState === letterClass)) {
                  state.lettersTried[guessedLetter] = letterClass
                  let keyboardBtn = document.querySelector('.key-' + guessedLetter)
                  if (keyboardBtn) {
                    keyboardBtn.classList.remove('incorrect', 'semi')
                    keyboardBtn.classList.add(keyboardKeyNextState)
                  }
                }
              }
              let anim = letterDiv.animate({ transform: [ 'rotateX(90deg)', 'rotateX(0deg)' ] }, {
                duration: animationDuration * 0.5,
                fill: 'forwards'
              })
              if (index === state.config.wordLength - 1) {
                anim.addEventListener('finish', () => {
                  resolve()
                  if (typeof onEndAnimation === 'function') {
                    onEndAnimation()
                  }
                })
              }
            })
        }
      })
    }

    function fillLetter (letter) {
      letter = letter.replace(/[^a-z]+/gi, '')
      if (letter.length !== 1) {
        return
      }
      let div = getLetterDiv()
      if (div) {
        let span = document.createElement('span')
        span.innerHTML = letter.toUpperCase()
        div.append(span)
        div.animate({
          transform: [ 'scale(1.0)', 'scale(1.16)', 'scale(1.0)' ],
          easing: [ 'ease-in-out', 'ease-in-out', 'ease-in-out' ]
        }, 50)
      }
    }

    function unfillLetter () {
      let div = getLetterDiv(true)
      if (div) {
        Array.from(div.children).forEach(node => node.remove())
      }
    }

    function clearLettersFilled () {
      for (let i = 0; i < state.config.wordLength; i++) {
        unfillLetter()
      }
    }

    function createWordRow (letterCount = 5) {
      let divWord = document.createElement('div')
      divWord.classList.add('word')
      for (let i = 0; i < letterCount; i++) {
        let divLetter = document.createElement('div')
        divLetter.classList.add('letter')
        divWord.append(divLetter)
      }
      return divWord
    }

    function setupKeyboard () {
      let keyboardDiv = document.querySelector('.keyboard')
      for (let child of keyboardDiv.children) {
        child.remove()
      }
      let layout = [ 'qwertyuiop', 'asdfghjkl', '#zxcvbnm!' ]
      for (let row of layout) {
        let keyboardRow = document.createElement('div')
        keyboardRow.classList.add('keyboard-row')
        for (let letter of Array.from(row)) {
          let extraClass
          if (letter === '#') {
            letter = 'Enter'
            extraClass = 'larger'
          } else if (letter === '!') {
            letter = 'Backspace'
            extraClass = 'larger'
          }
          let keyboardBtn = document.createElement('button')
          keyboardBtn.classList.add('keyboard-button', 'key-' + letter.toLowerCase())
          if (extraClass) {
            keyboardBtn.classList.add(extraClass)
          }
          keyboardBtn.innerHTML = letter === 'Backspace' ? SVG_BACKSPACE : letter
          keyboardBtn.onclick = (e) => {
            onType({ key: letter })
            e.stopPropagation()
            e.preventDefault()
          }
          if (letter === 'Backspace') {
            addOnLongTouchCallback(keyboardBtn, () => {
              clearLettersFilled()
            })
          }
          keyboardRow.append(keyboardBtn)
        }
        keyboardDiv.append(keyboardRow)
      }
    }

    function addOnLongTouchCallback (el, callback, delay = 650) {
      let timer = null
      el.addEventListener('touchstart', e => {
        if (timer) {
          clearTimeout(timer)
        }
        timer = setTimeout(() => {
          timer = null
          callback()
        }, delay)
      })
      el.addEventListener('touchend', e => {
        if (timer) {
          clearTimeout(timer)
          timer = null
        }
      })
    }

    function checkHardInput (word, ultra = false, stateData = state) {
      for (let attemptMade of stateData.wordsTried) {
        let wordToGuess = Array.from(stateData.wordToGuess)
        let currentGuess = Array.from(word)
        if (!attemptMade) {
          continue
        }
        attemptMade = Array.from(attemptMade)
        for (let index = 0; index < wordToGuess.length; index++) {
          let s = [ 'st', 'nd', 'rd' ][index] || 'th'
          if (attemptMade[index] === wordToGuess[index]) {
            if (currentGuess[index] !== attemptMade[index]) {
              return `${index + 1}${s} letter must be ${attemptMade[index].toUpperCase()}`
            }
            attemptMade[index] = undefined
            wordToGuess[index] = undefined
            currentGuess[index] = undefined
          } else if (
            ultra &&
            (
              (
                stateData.lettersTried[currentGuess[index]] === 'semi' &&
                attemptMade[index] === currentGuess[index]
              ) ||
              (
                stateData.lettersTried[currentGuess[index]] === 'correct' &&
                attemptMade[index] === currentGuess[index] &&
                wordToGuess[index] !== currentGuess[index]
              )
            )
          ) {
            return `${index + 1}${s} letter must not be ${currentGuess[index].toUpperCase()}`
          }
        }
        for (let index = 0; index < wordToGuess.length; index++) {
          if (attemptMade[index] && wordToGuess.includes(attemptMade[index])) {
            let currentGuessIndex = currentGuess.indexOf(attemptMade[index])
            let wordToGuessIndex = wordToGuess.indexOf(attemptMade[index])
            if (currentGuessIndex === -1) {
              return `Must contain letter ${attemptMade[index].toUpperCase()}`
            }
            currentGuess[currentGuessIndex] = undefined
            wordToGuess[wordToGuessIndex] = undefined
            attemptMade[index] = undefined
          }
        }
        if (ultra) {
          for (let index = 0; index < wordToGuess.length; index++) {
            if (currentGuess[index] && !stateData.wordToGuess.includes(currentGuess[index]) && stateData.lettersTried[currentGuess[index]] ) {
              return `Must not contain letter ${currentGuess[index].toUpperCase()}`
            }
            if (currentGuess[index] && /^(semi|correct)$/.test(stateData.lettersTried[currentGuess[index]])) {
              let regex = new RegExp(`[^${currentGuess[index]}]`, 'ig')
              let repetitions = word.replace(regex, '').length
              let lastAttemptRepetitions = stateData.wordsTried.slice(-1)[0].replace(regex, '').length
              let answerRepetitions = stateData.wordToGuess.replace(regex, '').length
              if (lastAttemptRepetitions > answerRepetitions && repetitions >= lastAttemptRepetitions) {
                return `There are too many ${currentGuess[index].toUpperCase()}s`
              }
            }
          }
        }
      }
    }

    function makeAttempt (word) {
      word = word.replace(/[^a-z]+/gi, '').toLowerCase()
      const dictionary = dictionaries[state.config.wordLength]
      if (word.length !== state.config.wordLength) {
        if (!isAnimatingHints() && !isGameOver()) {
          displayToast('Not enough letters')
        }
        return
      } else if (!dictionary || (!dictionary.wordsGuessable.has(word) && !dictionary.wordsAcceptable.has(word))) {
        return displayToast('Word not in dictionary')
      } else if (state.wordsTried.includes(word)) {
        return displayToast('Repeated word guess')
      } else if (isGameOver()) {
        return
      }
      if (state.config.hardMode || state.config.ultraHardMode) {
        const problem = checkHardInput(word, state.config.ultraHardMode)
        if (problem) {
          return displayToast(problem)
        }
      }
      displayToast()
      clearLettersFilled()
      for (const letter of word) {
        fillLetter(letter)
      }
      const div = getCurrentWordDiv()
      div.classList.add('attempted')
      state.previousAttemptState = cloneState()
      state.wordsTried.push(word)
      const hintsPromise = addHints(div)
      if (isGameOver()) {
        hintsPromise.then(() => setTimeout(() => onEndGame(), 500))
      } else {
        hintsPromise.then(() => setupCandidatesLeft())
      }
      saveState()
    }

    function getPossibleWordsLeft () {
      const dictionary = dictionaries[state.config.wordLength]
      const stateToConsider = isGameOver() ? state.previousAttemptState : state
      return [
        dictionary.wordsGuessable,
        dictionary.wordsAcceptable
      ]
        .flatMap(s => Array.from(s))
        .filter(w => !checkHardInput(w, state.config.ultraHardMode, stateToConsider))
    }

    function isGameOver () {
      return hasWon() || state.wordsTried.length >= state.config.attempts ||
        document.querySelector('.modal').classList.contains('show') ||
        document.body.classList.contains('game-over')
    }

    function hasWon () {
      return state.wordsTried.includes(state.wordToGuess)
    }

    function onType (e) {
      if (e.key === 'Enter') {
        makeAttempt(getCurrentTypedWord())
        onClickPlayAgain()
        if (typeof e.preventDefault === 'function') {
          e.preventDefault()
          e.stopPropagation()
        }
      } else if (/Backspace|Delete/.test(e.key)) {
        unfillLetter()
      } else if (/^[a-z]$/i.test(e.key)) {
        if (isGameOver()) {
          return
        }
        fillLetter(e.key)
      } else if (e.key === 'Escape' && !isGameOver()) {
        clearLettersFilled()
      }
    }

    function randomInteger (min = 0, max = 10) {
      return Math.floor(Math.random() * (max - min + 1) + min)
    }

    function codeToWordIndex (code, arrayLength) {
      const multiplier = Number(code.slice(0, 3))
      const xor = multiplier * 1e3 + multiplier
      let index = Number(code.slice(3))
      index = (index ^ xor) / multiplier
      if (arrayLength) {
        index %= arrayLength
      }
      return index
    }

    function wordIndexToCode (index, arrayLength) {
      const multiplier = randomInteger(150, 350)
      const xor = multiplier * 1e3 + multiplier
      if (arrayLength) {
        index += randomInteger(1, 13) * arrayLength
      }
      return String(multiplier) + String((index * multiplier) ^ xor)
    }

    function getWordToGuess (code) {
      const words = Array.from(dictionaries[state.config.wordLength].wordsGuessable || [])
      if (code) {
        return words[codeToWordIndex(code, words.length)]
      }
      return words[randomInteger(0, words.length - 1)]
    }

    function onCloseModal (callback) {
      let called = false
      let btnClose = document.querySelector('.modal-close')
      let func = () => {
        if (!called) {
          called = true
          callback()
        }
      }
      btnClose.addEventListener('click', func, { once: true })
    }

    function toggleModal (state) {
      let modal = document.querySelector('.modal')
      let backdrop = document.querySelector('.backdrop')
      if (state === undefined) {
        state = !modal.classList.contains('show')
      }
      if (state) {
        modal.classList.add('show')
        backdrop.classList.add('show')
      } else {
        modal.classList.remove('show')
        backdrop.classList.remove('show')
      }
    }

    function createShareButtonEl (style) {
      const shareButton = document.createElement('button')
      shareButton.classList.add('share-button')
      shareButton.innerHTML = 'Share ' + SVG_SHARE
      shareButton.onclick = () => {
        displayToast('Copied results to clipboard!', 2 * 1e3, 3e3)
        writeToClipboard(getShareContent())
      }
      if (style) {
        Object.assign(shareButton.style, style)
      }
      return shareButton
    }

    function setupEndGameModal () {
      let title = document.querySelector('.modal-title')
      let modalContent = document.querySelector('.modal-content')
      Array.from(modalContent.children).forEach(node => node.remove())
      if (title) {
        title.innerHTML = 'Statistics'
      }
      let statisticsGrid = document.createElement('div')
      statisticsGrid.classList.add('statistics')
      for (let label of [
        state.gamesPlayed,
        'Played',
        state.gamesWon,
        'Games\nWon',
        ((state.gamesWon / state.gamesPlayed * 100) || 0).toFixed(0),
        'Win %',
        state.victoryStreak,
        'Current\nStreak',
        state.victoryStreakRecord,
        'Max\nStreak'
      ]) {
        let span = document.createElement('span')
        span.textContent = label
        statisticsGrid.append(span)
      }
      modalContent.append(statisticsGrid)
      let distributionGrid = document.createElement('div')
      distributionGrid.classList.add('distribution')
      let bestGuessed = Math.max(...Object.values(state.guessDistribution))
      for (let attempt = 1; attempt <= state.config.attempts; attempt++) {
        let attemptLabel = document.createElement('span')
        attemptLabel.innerText = String(attempt)
        let distributionDiv = document.createElement('div')
        let distributionLabel = document.createElement('span')
        let distribution = state.guessDistribution[attempt] || 0
        distributionDiv.style.width = (6 + Math.floor(distribution / bestGuessed * 94)) + '%'
        distributionDiv.style.background = hasWon() && attempt === state.wordsTried.length
          ? '#538d4e'
          : '#3a3a3c'
        distributionLabel.innerText = distribution
        distributionDiv.append(distributionLabel)
        distributionGrid.append(attemptLabel, distributionDiv)
      }
      modalContent.append(distributionGrid)
      const shareButton = createShareButtonEl()
      modalContent.append(shareButton)
    }

    function getShareContent () {
      const decoder = new TextDecoder('utf-8')
      const squareGlyphs = [
        decoder.decode(new Uint8Array([ 226, 172, 155 ])),
        decoder.decode(new Uint8Array([ 240, 159, 159, 168 ])),
        decoder.decode(new Uint8Array([ 240, 159, 159, 169 ]))
      ]
      const colorMatrix = Array.from(document.querySelectorAll('.word'))
        .map(row => {
          return Array.from(row.children)
            .map(letter => {
              const glyphIndex = (letter.classList.contains('correct') && 2) ||
                (letter.classList.contains('semi') && 1) ||
                (letter.classList.contains('incorrect') && 0)
              return squareGlyphs[glyphIndex] || ''
            })
            .join('')
        })
        .filter(row => row)
      const word = document.getElementById('word-answer').innerHTML
      const wordIndex = wordsGuessable.indexOf(word.toLowerCase())
      const url = new URL(window.location)
      url.searchParams.set('word', wordIndexToCode(wordIndex, wordsGuessable.length))
      const text = [
        `Unlimited Wordle ${colorMatrix.length}/${state.config.attempts}`,
        ...colorMatrix,
        `Try to guess this word here: ${url.toString()}`
      ].join('\n')
      return text
    }

    async function writeToClipboard (content) {
      let success = false
      try {
        const result = await navigator.permissions.query({ name: 'clipboard-write' })
        if (result.state === 'granted') {
          await navigator.clipboard.writeText(content)
          success = true
        } else {
          throw new Error('forbidden')
        }
      } catch (err) {
      }
      if (!success) {
        const element = document.createElement('div')
        element.innerHTML = content
        Object.assign(element.style, {
          opacity: 0,
          pointerEvents: 'none',
          position: 'fixed',
          transform: 'translateX(-100%)',
          whiteSpace: 'pre'
        })
        document.body.append(element)
        const selection = window.getSelection()
        const range = document.createRange()
        range.selectNodeContents(element)
        selection.removeAllRanges()
        selection.addRange(range)
        const result = document.execCommand('copy')
        setTimeout(() => element.remove(), 100)
      }
    }

    function onEndGame (toastDuration = 1.5e3) {
      let victory = hasWon()
      let endMessagesArray = endMessages[victory ? 'positive' : 'negative' ]
      let message = endMessagesArray[randomInteger(0, endMessagesArray.length - 1)] + '!'
      if (!victory) {
        message += '\nAnswer: ' + state.wordToGuess.toUpperCase()
        toastDuration *= 2
      }
      if (victory) {
        state.gamesWon++
        state.guessDistribution[state.wordsTried.length] = (state.guessDistribution[state.wordsTried.length] || 0) + 1
        state.victoryStreak++
        state.victoryStreakRecord = Math.max(state.victoryStreakRecord, state.victoryStreak)
      } else {
        state.victoryStreak = 0
      }
      state.gamesPlayed++
      state.previousGame = cloneState()
      saveState()
      displayToast(message, toastDuration)
      setTimeout(() => {
        setupEndGameModal()
        toggleModal(true)
        resetGame()
        saveState()
        onCloseModal(() => {
          document.body.classList.add('game-over')
        })
      }, toastDuration)
    }

    function onClickPlayAgain () {
      if (document.body.classList.contains('game-over') &&
          document.querySelector('.end-actions button').getAnimations().every(a => a.playState === 'finished')) {
        const autoFirstAttempt = state.config.autoFirstWord && document.getElementById('word-answer').innerHTML
        resetGame(true)
        setupCandidatesLeft()
        if (autoFirstAttempt) {
          makeAttempt(autoFirstAttempt)
        }
      }
    }

    function saveState () {
      localStorage.setItem('state', JSON.stringify(state))
    }

    function mergeObjs (src, obj) {
      if (typeof src !== 'object' || !src ||
          typeof obj !== 'object' || !obj) {
        return src
      }
      for (let key in obj) {
        let srcValue = src[key]
        let objValue = obj[key]
        if (typeof srcValue === 'object' && srcValue &&
            typeof objValue === 'object' && objValue) {
          mergeObjs(srcValue, objValue)
        } else {
          src[key] = objValue
        }
      }
      return src
    }

    function loadState () {
      try {
        let data = JSON.parse(localStorage.getItem('state'))
        if (data) {
          mergeObjs(state, data)
        }
        return state
      } catch (err) {
      }
    }

    function setupCandidatesLeft () {
      const el = document.getElementById('candidates-left')
      if (el) {
        if (state.config.displayCandidates) {
          el.innerHTML = `Candidates left: ${getPossibleWordsLeft().length}`
          el.style.display = ''
        } else {
          el.style.display = 'none'
        }
      }
    }

    function addSliderSetting (key, name, description) {
      const settingsEl = document.querySelector('.settings')
      settingsEl.innerHTML += '<br><div><div style="display: flex; flex-direction: column; max-width: 75%;"><span style="font-size: 18px;">' + name + '</span><span style="font-size: 12px; color: #787c7e;">' + description + '</span></div><div class="slider" prop="' + key + '"></div></div><div class="line-sep"></div>'
    }

    function setupUI () {
      addSliderSetting('hardMode', 'Hard Mode', 'Any revealed hints must be used in subsequent guesses.')
      addSliderSetting('ultraHardMode', 'Ultra Hard Mode', 'Forbids you to use letters that have already been tried and place yellow letters on the same slot. This also enables Hard Mode.')
      addSliderSetting('displayCandidates', 'Display Candidates Count', 'Shows how many words can be attempted that match every hint received.')
      addSliderSetting('autoFirstWord', 'Auto First Word', 'Starts the next game with the word from the previous round.')
      addSliderSetting('quickAnimations', 'Quick Animations', 'Makes animations run much quicker.')
      setupWordList()
      setupKeyboard()

      const endActionsDiv = document.querySelector('.end-actions')
      const shareButton = createShareButtonEl({ padding: '12px', gridRow: 'span 2' })
      endActionsDiv.prepend(shareButton)

      const btnHowToPlay = document.getElementById('howtoplay')
      btnHowToPlay.innerHTML = SVG_HOWTO
      btnHowToPlay.addEventListener('click', e => {
        document.querySelector('.overlay').classList.add('show')
        document.querySelector('.howtoplay').classList.add('show')
        document.querySelector('.settings').classList.remove('show')
      })
      const btnCloseHowToPlay = document.querySelector('.howtoplay-close')
      btnCloseHowToPlay.innerHTML = SVG_CLOSE
      btnCloseHowToPlay.addEventListener('click', e => {
        document.querySelector('.overlay').classList.remove('show')
      })

      const btnStats = document.getElementById('stats')
      btnStats.innerHTML = SVG_STATS
      btnStats.addEventListener('click', e => {
        setupEndGameModal()
        toggleModal(true)
      })

      const btnSettings = document.getElementById('settings')
      btnSettings.innerHTML = SVG_SETTINGS
      btnSettings.addEventListener('click', e => {
        document.querySelector('.overlay').classList.add('show')
        document.querySelector('.howtoplay').classList.remove('show')
        document.querySelector('.settings').classList.add('show')
      })
      const btnCloseSettings = document.querySelector('.settings-close')
      btnCloseSettings.innerHTML = SVG_CLOSE
      btnCloseSettings.addEventListener('click', e => {
        document.querySelector('.overlay').classList.remove('show')
      })

      const btnCloseModal = document.querySelector('.modal-close')
      const backdrop = document.querySelector('.backdrop')
      btnCloseModal.innerHTML = SVG_CLOSE
      btnCloseModal.addEventListener('click', (e) => {
        if (!document.querySelector('.modal').classList.contains('show')) {
          e.preventDefault()
          e.stopPropagation()
          return
        }
        toggleModal(false)
      }, { capture: true })
      backdrop.addEventListener('click', () => {
        if (backdrop.getAnimations().some(a => a.playState !== 'finished')) {
          return
        }
        btnCloseModal.click()
        btnCloseHowToPlay.click()
        btnCloseSettings.click()
      })

      Array.from(document.querySelectorAll('.slider'))
        .forEach(node => {
          let prop = node.getAttribute('prop')
          if (state.config[prop]) {
            node.classList.add('on')
          }
        })

      window.addEventListener('click', e => {
        if (e.target.classList.contains('slider')) {
          e.preventDefault()
          e.stopPropagation()
          if (/^(|true)$/i.test(e.target.getAttribute('disabled'))) {
            return
          }
          if (e.target.classList.contains('on')) {
            e.target.classList.remove('on')
          } else {
            e.target.classList.add('on')
          }
          let prop = e.target.getAttribute('prop')
          onSliderChange(prop, e.target.classList.contains('on'))
        }
      })

      window.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
          backdrop.click()
        }
      })
    }

    function setupDictionary () {
      for (let word of wordsGuessable) {
        addWordToDict(word, true)
      }
      for (let word of wordsAcceptedAsInput) {
        addWordToDict(word, false)
      }
    }

    function setupForCurrentState () {
      document.querySelector('.end-actions span').innerText = state.wordToGuess.toUpperCase()
      let lettersAndKeys = [
        ...document.querySelectorAll('.keyboard-button'),
        ...document.querySelectorAll('.letter')
      ].flat()
      lettersAndKeys.forEach(node => {
        node.classList.remove('correct', 'semi', 'incorrect')
      })
      let wordList = Array.from(document.querySelector('.words').children)
      for (let wordTriedIndex = 0; wordTriedIndex < state.wordsTried.length; wordTriedIndex++) {
        let wordDiv = wordList[wordTriedIndex]
        let letterList = Array.from(wordDiv.children)
        let wordTried = Array.from(state.wordsTried[wordTriedIndex])
        for (let letterIndex = 0; letterIndex < wordTried.length; letterIndex++) {
          let letter = wordTried[letterIndex]
          let letterDiv = letterList[letterIndex]
          if (letterDiv) {
            Array.from(letterDiv.children).forEach(node => node.remove())
            let span = document.createElement('span')
            span.innerText = letter.toUpperCase()
            letterDiv.append(span)
          }
        }
        const promise = addHints(wordDiv, null, true)
        if (wordTriedIndex === state.wordsTried.length - 1) {
          promise.then(() => setupCandidatesLeft())
        }
      }
      if (state.wordsTried.length === 0) {
        setupCandidatesLeft()
      }
    }

    function setupWordList () {
      const divWordList = document.querySelector('.words')
      Array.from(divWordList.children).forEach(node => node.remove())
      for (let i = 0; i < state.config.attempts; i++) {
        let divWord = createWordRow()
        divWordList.append(divWord)
      }
    }

    function resetGame (resetInterface, nextWord) {
      state.wordsTried = []
      state.lettersTried = {}
      state.wordToGuess = nextWord || getWordToGuess()
      if (resetInterface) {
        resetUI()
      }
    }

    function resetUI () {
      setupWordList()
      setupForCurrentState()
      document.body.classList.remove('game-over')
    }

    function resetStatistics () {
      state.gamesPlayed = 0
      state.gamesWon = 0
      state.guessDistribution = {}
      state.victoryStreak = 0
      state.victoryStreakRecord = 0
      saveState()
    }

    function updateConfig (newConfig) {
      Object.assign(state.config, newConfig)
      saveState()
    }

    function onSliderChange (prop, bool) {
      if (prop in state.config) {
        state.config[prop] = !!bool
        saveState()
      }
      if (/displayCandidates|hard/i.test(prop)) {
        setupCandidatesLeft()
      }
    }

    function onInit () {
      loadState()

      window.addEventListener('keydown', onType, { capture: true })

      setupDictionary()
      setupUI()

      const url = new URL(window.location)
      const urlWord = url.searchParams.get('word')
      if (urlWord) {
        resetGame()
        const word = getWordToGuess(urlWord)
        if (word) {
          state.wordToGuess = word
          displayToast('Guess the word given by the link!', 3 * 1e3)
          const newUrl = new URL(window.location)
          newUrl.searchParams.delete('word')
          window.history.replaceState({}, document.title, newUrl.toString())
        } else {
          displayToast('Word from link is invalid.\nWill use random word', 8 * 1e3)
        }
      } else if (!state.wordToGuess) {
        resetGame()
      }

      setupForCurrentState()

      if (isGameOver()) {
        setTimeout(() => {
          if (isGameOver()) {
            onEndGame()
          }
        }, 1e3)
      }
    }

    const endMessages = {
      positive:
      [ 'Great', 'Fantastic', 'Wonderful', 'Brilliant', 'Super', 'Incredible', 'Alright', 'Good one', 'Perfect', 'On point', 'Amazing', 'Spectacular', 'Awesome', 'Remarkable', 'Marvelous', 'Magnificent', 'Splendid', 'Bullseye' ],
      negative: [ 'Oh no', 'Oops', 'Sorry', 'Not quite', 'Almost', 'Close one', 'Maybe next time', 'Aaw snap' ]
    }

    const SVG_SHARE = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path fill="currentColor" d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92c0-1.61-1.31-2.92-2.92-2.92zM18 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM6 13c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm12 7.02c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"></path></svg>'

    const SVG_HOWTO = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path fill="currentColor" d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"></path></svg>'

    const SVG_STATS = ''

    const SVG_SETTINGS = ''

    const SVG_CLOSE = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>'

    const SVG_BACKSPACE = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path fill="currentColor" d="M22 3H7c-.69 0-1.23.35-1.59.88L0 12l5.41 8.11c.36.53.9.89 1.59.89h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H7.07L2.4 12l4.66-7H22v14zm-11.59-2L14 13.41 17.59 17 19 15.59 15.41 12 19 8.41 17.59 7 14 10.59 10.41 7 9 8.41 12.59 12 9 15.59z"></path></svg>'

    function addWordToDict (word, guessable) {
      let length = word.length
      let dictInfo = dictionaries[length]
      if (!dictInfo) {
        dictInfo = {
          wordsGuessable: new Set(),
          wordsAcceptable: new Set()
        }
        dictionaries[length] = dictInfo
      }
      if (guessable) {
        dictInfo.wordsGuessable.add(word)
      } else {
        dictInfo.wordsAcceptable.add(word)
      }
    }

    const wordsGuessable = [ "water", "apple", "chair", "house", "table", "bread", "earth", "clock", "lemon", "grape", "smile", "plant", 
    "queen", "horse", "paper", "music", "black", "green", "white", "brown", "money", "angel", "candy", "child", "clear", "happy", "dress", 
    "beach", "round", "dance", "sweet", "dream", "space", "stars", "peach", "pizza", "tiger", "train", "radio", "river", "shoes", 
    "paint", "stone", "ghost", "magic", "panda", "koala", "snake", "ocean", ]

     const wordsAcceptedAsInput = [ "water", "apple", "chair", "house", "table", "bread", "earth", "clock", "lemon", "grape", "smile","plant", "queen", "horse", "paper", "music", "black", "green", "white", "brown", "money", "angel", "candy", "child", "clear", "happy", "dress", "beach", "round", "dance", "sweet", "dream", "space", "stars", "peach", "pizza", "tiger", "train", "radio", "river", "shoes", "paint", "stone", "ghost", "magic", "panda", "koala", "snake", "ocean", ]
  </script>
</html>
